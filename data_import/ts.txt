# -*- coding: utf-8 -*-
from odoo import models, fields, api
import csv
import logging
import ast
from contextlib import closing
from concurrent.futures import ThreadPoolExecutor, as_completed
import multiprocessing
import threading
import odoo

_logger = logging.getLogger(__name__)

class ProductCategory(models.Model):
    _inherit = 'product.category'
    external_id = fields.Char('External ID', index=True)

class ProductTemplate(models.Model):
    _inherit = 'product.template'
    external_id = fields.Char('External ID', index=True)

class DataImporter(models.TransientModel):
    _name = 'data.importer'
    _description = 'Data Import Wizard'
        
    def _create_or_get_external_id(self, env, record_id, model, external_id, module='__import__'):
        """Create external ID if it doesn't exist, or get existing one"""
        existing = env['ir.model.data'].search([
            ('name', '=', external_id),
            ('model', '=', model),
            ('module', '=', module)
        ], limit=1)
        
        if existing:
            return existing
            
        return env['ir.model.data'].create({
            'name': external_id,
            'model': model,
            'module': module,
            'res_id': record_id,
            'noupdate': True
        })

    def _process_record_with_new_cursor(self, dbname, uid, context, row):
        """Process a record with a new cursor"""
        with api.Environment.manage():
            registry = odoo.registry(dbname)
            with closing(registry.cursor()) as cr:
                try:
                    env = api.Environment(cr, uid, context)
                    return self._process_single_product(env, row)
                except Exception as e:
                    _logger.error(f"Error processing record {row.get('id')}: {e}")
                    if cr:
                        cr.rollback()
                    return False

    def _process_single_product(self, env, row):
        """Process single product record with original category logic"""
        try:
            external_product_id = row.get('id')
            product_exists = env['product.template'].search([
                ('external_id', '=', external_product_id)
            ], limit=1)
            
            if product_exists:
                _logger.info(f"Product with ID {external_product_id} already exists. Skipping creation...")
                return True

            # Parse category data - keeping original logic
            category = ast.literal_eval(row['categ_id'])
            category_id, category_name = category if isinstance(category, tuple) else ast.literal_eval(category)
            category_path = category_name.split(' / ')

            _logger.info(f"Processing category ID: {category_id}, Name: {category_name}")

            # Find or create categories
            parent_id = False
            final_category = None
            path_external_id = None
            
            # Process each level of the category path - keeping original logic
            for path in category_path:
                category = env['product.category'].search([
                    ('name', '=', path),
                    ('parent_id', '=', parent_id)
                ], limit=1)
                
                if not category:
                    category = env['product.category'].create({
                        'name': path,
                        'parent_id': parent_id,
                        'external_id': str(category_id) if path == category_path[-1] else None
                    })
                
                parent_id = category.id
                final_category = category
                
                # Only create external ID for the leaf category
                if path == category_path[-1]:
                    path_external_id = f'product_category_{category_id}'
                    self._create_or_get_external_id(
                        env,
                        category.id,
                        'product.category',
                        path_external_id
                    )

            # Create product with improved error handling
            try:
                product_vals = {
                    'name': row.get('name', '').strip(),
                    'default_code': row.get('default_code', '').strip(),
                    'categ_id': final_category.id,
                    'type': 'product',
                    'list_price': float(row.get('list_price', 0) or 0),
                    'sale_ok': bool(row.get('sale_ok', False)),
                    'purchase_ok': bool(row.get('purchase_ok', False)),
                    'external_id': row.get('id')  # Store the original ID
                }

                product = env['product.template'].create(product_vals)
                _logger.info(f"Created product: {product.name}")
                
                # Create external ID for product if ID exists
                if row.get('id'):
                    product_external_id = f'product_template_{row["id"]}'
                    self._create_or_get_external_id(
                        env,
                        product.id,
                        'product.template',
                        product_external_id
                    )
                
                env.cr.commit()
                return True

            except Exception as product_error:
                _logger.error(f"Error creating product: {product_error}")
                env.cr.rollback()
                return False

        except Exception as row_error:
            _logger.error(f"Error processing row: {row_error}")
            if env and env.cr:
                env.cr.rollback()
            return False

    def import_products(self):
        try:
            file_path = '/home/dell/Documents/Projects/PrimaPaint/odoo-15.0/primapaint_addons/data_import/models/product-data.csv'
            
            # Read all records first
            with open(file_path, 'r', encoding='utf-8') as file:
                reader = csv.DictReader(file, delimiter='\t')
                records = [row for row in reader if row.get('id') and row['id'].strip()]
                
            total_records = len(records)
            _logger.info(f"Starting import of {total_records} products")
            
            # Calculate optimal number of workers
            max_workers = min(multiprocessing.cpu_count() * 2, total_records)
            successful_imports = 0
            
            # Store current environment details
            dbname = self.env.cr.dbname
            uid = self.env.uid
            context = self.env.context
            
            # Process records using ThreadPoolExecutor
            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                # Submit all tasks with new cursor for each
                future_to_record = {
                    executor.submit(
                        self._process_record_with_new_cursor, 
                        dbname, 
                        uid, 
                        context,
                        record
                    ): record for record in records
                }
                
                # Process completed tasks
                for future in as_completed(future_to_record):
                    record = future_to_record[future]
                    try:
                        if future.result():
                            successful_imports += 1
                    except Exception as e:
                        _logger.error(f"Error processing record {record.get('id')}: {e}")
            
            _logger.info(f"Import completed. Successfully imported {successful_imports} out of {total_records} products")
            return {'type': 'ir.actions.client', 'tag': 'reload'}
            
        except Exception as e:
            _logger.error(f"Error in import process: {e}")
            return False

    def import_all_data(self):
        _logger.info("Starting product import process...")
        return self.import_products